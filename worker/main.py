"""Worker entry point — runs on Fly.io Machine (scale-to-zero).

Reads audit configuration from environment variables,
runs the epistemic engine, writes results back to Supabase,
then exits (machine auto-destroys).
"""

from __future__ import annotations

import os
import sys
import traceback

from epistemix.connector import MockConnector, BaseConnector, ClaudeConnector
from epistemix.core import EpistemixEngine
from epistemix.models import Finding, Anomaly, CycleSnapshot
from epistemix.multi_agent import MultiAgentSystem
from supabase_writer import SupabaseWriter


def create_connector() -> BaseConnector:
    """Create the appropriate connector based on available credentials."""
    api_key = os.environ.get("ANTHROPIC_API_KEY")
    if api_key:
        return ClaudeConnector(
            api_key=api_key,
            model=os.environ.get("CLAUDE_MODEL", "claude-sonnet-4-20250514"),
            max_budget=float(os.environ.get("MAX_BUDGET", "10.0")),
        )
    else:
        # Fallback to mock for development/testing
        print("WARNING: No ANTHROPIC_API_KEY — running in mock mode")
        return MockConnector()


def serialize_finding(f: Finding) -> dict:
    return {
        "source": f.source,
        "language": f.language,
        "author": f.author,
        "institution": f.institution,
        "theory_supported": f.theory_supported,
        "source_type": f.source_type,
        "year": f.year,
        "entities_mentioned": f.entities_mentioned,
        "cycle": f.cycle,
    }


def serialize_anomaly(a: Anomaly) -> dict:
    return {
        "description": a.description,
        "gap_type": a.gap_type.value,
        "severity": a.severity.value,
        "recommendation": a.recommendation,
        "suggested_queries": a.suggested_queries,
        "detected_at_cycle": a.detected_at_cycle,
    }


def main() -> None:
    audit_id = os.environ["AUDIT_ID"]
    topic = os.environ["AUDIT_TOPIC"]
    country = os.environ["AUDIT_COUNTRY"]
    discipline = os.environ["AUDIT_DISCIPLINE"]
    max_cycles = int(os.environ.get("AUDIT_MAX_CYCLES", "4"))

    writer = SupabaseWriter(audit_id)

    try:
        print(f"Starting audit: {topic} / {country} / {discipline}")
        print(f"Max cycles: {max_cycles}")

        connector = create_connector()

        # --- Phase 1: Single engine audit ---
        engine = EpistemixEngine(
            country=country,
            topic=topic,
            discipline=discipline,
        )

        # Seed queries
        queries = engine.initialize()

        # Execute seed queries and ingest findings
        seed_findings = connector.execute_batch(queries)
        engine.ingest_findings(seed_findings)

        # Run cycles for real-time progress updates
        for cycle in range(max_cycles):
            snapshot = engine.run_cycle()

            # Write progress after each cycle
            coverage_history = [
                s.to_dict() for s in engine.cycle_history
            ]
            writer.update_cycle(
                cycle=snapshot.cycle,
                coverage_history=coverage_history,
            )
            writer.write_findings([serialize_finding(f) for f in engine.findings])
            writer.write_anomalies([serialize_anomaly(a) for a in engine.all_anomalies])

            print(f"Cycle {snapshot.cycle}: coverage={snapshot.coverage_score:.1f}%, "
                  f"findings={snapshot.n_findings}, anomalies={snapshot.n_anomalies}")

            # Execute gap-filling queries generated by this cycle
            if engine.pending_queries:
                new_findings = connector.execute_batch(engine.pending_queries)
                engine.ingest_findings(new_findings)

            # Check convergence after cycle 2+
            if cycle >= 2 and len(engine.cycle_history) >= 2:
                prev = engine.cycle_history[-2].coverage_score
                curr = snapshot.coverage_score
                if curr - prev < 2.0:
                    print(f"Convergence reached at cycle {snapshot.cycle}")
                    break

        # --- Phase 2: Multi-agent analysis ---
        print("\nRunning multi-agent analysis...")
        mas = MultiAgentSystem(engine.postulates)
        multi_result = mas.run(engine.findings)
        writer.write_multi_agent_result(multi_result)

        # --- Phase 3: Write detailed records ---
        writer.write_detailed_findings(
            audit_id,
            [serialize_finding(f) for f in engine.findings],
        )
        writer.write_detailed_anomalies(
            audit_id,
            [serialize_anomaly(a) for a in engine.all_anomalies],
        )

        # --- Done ---
        last_coverage = engine.cycle_history[-1].coverage_score if engine.cycle_history else 0
        writer.update_status("complete")
        print(f"\nAudit complete. Final coverage: {last_coverage:.1f}%")

    except Exception as e:
        traceback.print_exc()
        writer.update_status("failed", error_message=str(e))
        sys.exit(1)


if __name__ == "__main__":
    main()
